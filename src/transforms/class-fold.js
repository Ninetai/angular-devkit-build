"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const ts = require("typescript");
function getFoldFileTransformer(program) {
    const checker = program.getTypeChecker();
    return (context) => {
        const transformer = (sf) => {
            const statementsToRemove = [];
            const classesWithoutStatements = findClassDeclarations(sf);
            let classes = findClassesWithStaticPropertyAssignments(sf, checker, classesWithoutStatements);
            const visitor = (node) => {
                if (classes.length === 0 && statementsToRemove.length === 0) {
                    // There are no more statements to fold.
                    return ts.visitEachChild(node, visitor, context);
                }
                // Check if node is a statement to be dropped.
                const stmtIdx = statementsToRemove.indexOf(node);
                if (stmtIdx != -1) {
                    statementsToRemove.splice(stmtIdx, 1);
                    return undefined;
                }
                // Check if node is a ES5 class to add statements to.
                let clazz = classes.find((cl) => cl.function === node);
                if (clazz) {
                    const functionExpression = node;
                    // Create a new body with all the original statements, plus new ones,
                    // plus return statement.
                    const newBody = ts.createBlock([
                        ...functionExpression.body.statements.slice(0, -1),
                        ...clazz.statements.map(st => st.expressionStatement),
                        ...functionExpression.body.statements.slice(-1),
                    ]);
                    const newNode = ts.createFunctionExpression(functionExpression.modifiers, functionExpression.asteriskToken, functionExpression.name, functionExpression.typeParameters, functionExpression.parameters, functionExpression.type, newBody);
                    // Update remaining classes and statements.
                    statementsToRemove.push(...clazz.statements.map(st => st.expressionStatement));
                    classes = classes.filter(cl => cl != clazz);
                    // Replace node with modified one.
                    return newNode;
                }
                // Check if node is a ES2015 class to replace with a pure IIFE.
                clazz = classes.find((cl) => !cl.function && cl.declaration === node);
                if (clazz) {
                    const classStatement = clazz.declaration;
                    const innerReturn = ts.createReturn(ts.createIdentifier(clazz.name));
                    const iife = ts.createImmediatelyInvokedFunctionExpression([
                        classStatement,
                        ...clazz.statements.map(st => st.expressionStatement),
                        innerReturn,
                    ]);
                    const pureIife = ts.addSyntheticLeadingComment(iife, ts.SyntaxKind.MultiLineCommentTrivia, '@__PURE__', false);
                    // Move the original class modifiers to the var statement.
                    const newNode = ts.createVariableStatement(clazz.declaration.modifiers, ts.createVariableDeclarationList([
                        ts.createVariableDeclaration(clazz.name, undefined, pureIife),
                    ], ts.NodeFlags.Const));
                    clazz.declaration.modifiers = undefined;
                    // Update remaining classes and statements.
                    statementsToRemove.push(...clazz.statements.map(st => st.expressionStatement));
                    classes = classes.filter(cl => cl != clazz);
                    return newNode;
                }
                // Otherwise return node as is.
                return ts.visitEachChild(node, visitor, context);
            };
            return ts.visitNode(sf, visitor);
        };
        return transformer;
    };
}
exports.getFoldFileTransformer = getFoldFileTransformer;
function findClassDeclarations(node) {
    const classes = [];
    // Find all class declarations, build a ClassData for each.
    ts.forEachChild(node, (child) => {
        // Check if it is a named class declaration first.
        // Technically it doesn't need a name in TS if it's the default export, but when downleveled
        // it will be have a name (e.g. `default_1`).
        if (ts.isClassDeclaration(child) && child.name) {
            classes.push({
                name: child.name.text,
                declaration: child,
                statements: [],
            });
            return;
        }
        if (child.kind !== ts.SyntaxKind.VariableStatement) {
            return;
        }
        const varStmt = child;
        if (varStmt.declarationList.declarations.length > 1) {
            return;
        }
        const varDecl = varStmt.declarationList.declarations[0];
        if (varDecl.name.kind !== ts.SyntaxKind.Identifier) {
            return;
        }
        const name = varDecl.name.text;
        const expr = varDecl.initializer;
        if (!expr || expr.kind !== ts.SyntaxKind.ParenthesizedExpression) {
            return;
        }
        if (expr.expression.kind !== ts.SyntaxKind.CallExpression) {
            return;
        }
        const callExpr = expr.expression;
        if (callExpr.expression.kind !== ts.SyntaxKind.FunctionExpression) {
            return;
        }
        const fn = callExpr.expression;
        if (fn.body.statements.length < 2) {
            return;
        }
        if (fn.body.statements[0].kind !== ts.SyntaxKind.FunctionDeclaration) {
            return;
        }
        const innerFn = fn.body.statements[0];
        if (fn.body.statements[fn.body.statements.length - 1].kind !== ts.SyntaxKind.ReturnStatement) {
            return;
        }
        if (!innerFn.name || innerFn.name.kind !== ts.SyntaxKind.Identifier) {
            return;
        }
        if (innerFn.name.text !== name) {
            return;
        }
        classes.push({
            name,
            declaration: varDecl,
            function: fn,
            statements: [],
        });
    });
    return classes;
}
function findClassesWithStaticPropertyAssignments(node, checker, classes) {
    // Find each assignment outside of the declaration.
    ts.forEachChild(node, (child) => {
        if (child.kind !== ts.SyntaxKind.ExpressionStatement) {
            return;
        }
        const expressionStatement = child;
        if (expressionStatement.expression.kind !== ts.SyntaxKind.BinaryExpression) {
            return;
        }
        const binEx = expressionStatement.expression;
        if (binEx.left.kind !== ts.SyntaxKind.PropertyAccessExpression) {
            return;
        }
        const propAccess = binEx.left;
        if (propAccess.expression.kind !== ts.SyntaxKind.Identifier) {
            return;
        }
        const symbol = checker.getSymbolAtLocation(propAccess.expression);
        if (!symbol) {
            return;
        }
        const decls = symbol.declarations;
        if (decls == undefined || decls.length === 0) {
            return;
        }
        const hostClass = classes.find((clazz => decls.includes(clazz.declaration)));
        if (!hostClass) {
            return;
        }
        const statement = { expressionStatement, hostClass };
        hostClass.statements.push(statement);
    });
    // Only return classes that have static property assignments.
    return classes.filter(cl => cl.statements.length != 0);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xhc3MtZm9sZC5qcyIsInNvdXJjZVJvb3QiOiIuLyIsInNvdXJjZXMiOlsicGFja2FnZXMvYW5ndWxhcl9kZXZraXQvYnVpbGRfb3B0aW1pemVyL3NyYy90cmFuc2Zvcm1zL2NsYXNzLWZvbGQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7Ozs7O0dBTUc7QUFDSCxpQ0FBaUM7QUFjakMsU0FBZ0Isc0JBQXNCLENBQUMsT0FBbUI7SUFDeEQsTUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLGNBQWMsRUFBRSxDQUFDO0lBRXpDLE9BQU8sQ0FBQyxPQUFpQyxFQUFpQyxFQUFFO1FBRTFFLE1BQU0sV0FBVyxHQUFrQyxDQUFDLEVBQWlCLEVBQUUsRUFBRTtZQUV2RSxNQUFNLGtCQUFrQixHQUE2QixFQUFFLENBQUM7WUFDeEQsTUFBTSx3QkFBd0IsR0FBRyxxQkFBcUIsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUMzRCxJQUFJLE9BQU8sR0FBRyx3Q0FBd0MsQ0FBQyxFQUFFLEVBQUUsT0FBTyxFQUFFLHdCQUF3QixDQUFDLENBQUM7WUFFOUYsTUFBTSxPQUFPLEdBQWUsQ0FBQyxJQUFhLEVBQTJCLEVBQUU7Z0JBQ3JFLElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksa0JBQWtCLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtvQkFDM0Qsd0NBQXdDO29CQUN4QyxPQUFPLEVBQUUsQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztpQkFDbEQ7Z0JBRUQsOENBQThDO2dCQUM5QyxNQUFNLE9BQU8sR0FBRyxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsSUFBOEIsQ0FBQyxDQUFDO2dCQUMzRSxJQUFJLE9BQU8sSUFBSSxDQUFDLENBQUMsRUFBRTtvQkFDakIsa0JBQWtCLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQztvQkFFdEMsT0FBTyxTQUFTLENBQUM7aUJBQ2xCO2dCQUVELHFEQUFxRDtnQkFDckQsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLFFBQVEsS0FBSyxJQUFJLENBQUMsQ0FBQztnQkFDdkQsSUFBSSxLQUFLLEVBQUU7b0JBQ1QsTUFBTSxrQkFBa0IsR0FBRyxJQUE2QixDQUFDO29CQUV6RCxxRUFBcUU7b0JBQ3JFLHlCQUF5QjtvQkFDekIsTUFBTSxPQUFPLEdBQUcsRUFBRSxDQUFDLFdBQVcsQ0FBQzt3QkFDN0IsR0FBRyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7d0JBQ2xELEdBQUcsS0FBSyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsbUJBQW1CLENBQUM7d0JBQ3JELEdBQUcsa0JBQWtCLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7cUJBQ2hELENBQUMsQ0FBQztvQkFFSCxNQUFNLE9BQU8sR0FBRyxFQUFFLENBQUMsd0JBQXdCLENBQ3pDLGtCQUFrQixDQUFDLFNBQVMsRUFDNUIsa0JBQWtCLENBQUMsYUFBYSxFQUNoQyxrQkFBa0IsQ0FBQyxJQUFJLEVBQ3ZCLGtCQUFrQixDQUFDLGNBQWMsRUFDakMsa0JBQWtCLENBQUMsVUFBVSxFQUM3QixrQkFBa0IsQ0FBQyxJQUFJLEVBQ3ZCLE9BQU8sQ0FDUixDQUFDO29CQUVGLDJDQUEyQztvQkFDM0Msa0JBQWtCLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDO29CQUMvRSxPQUFPLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxLQUFLLENBQUMsQ0FBQztvQkFFNUMsa0NBQWtDO29CQUNsQyxPQUFPLE9BQU8sQ0FBQztpQkFDaEI7Z0JBRUQsK0RBQStEO2dCQUMvRCxLQUFLLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsUUFBUSxJQUFJLEVBQUUsQ0FBQyxXQUFXLEtBQUssSUFBSSxDQUFDLENBQUM7Z0JBQ3RFLElBQUksS0FBSyxFQUFFO29CQUNULE1BQU0sY0FBYyxHQUFHLEtBQUssQ0FBQyxXQUFrQyxDQUFDO29CQUNoRSxNQUFNLFdBQVcsR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztvQkFFckUsTUFBTSxJQUFJLEdBQUcsRUFBRSxDQUFDLDBDQUEwQyxDQUFDO3dCQUN6RCxjQUFjO3dCQUNkLEdBQUcsS0FBSyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsbUJBQW1CLENBQUM7d0JBQ3JELFdBQVc7cUJBQ1osQ0FBQyxDQUFDO29CQUVILE1BQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQywwQkFBMEIsQ0FDNUMsSUFBSSxFQUNKLEVBQUUsQ0FBQyxVQUFVLENBQUMsc0JBQXNCLEVBQ3BDLFdBQVcsRUFDWCxLQUFLLENBQ04sQ0FBQztvQkFFRiwwREFBMEQ7b0JBQzFELE1BQU0sT0FBTyxHQUFHLEVBQUUsQ0FBQyx1QkFBdUIsQ0FDeEMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxTQUFTLEVBQzNCLEVBQUUsQ0FBQyw2QkFBNkIsQ0FBQzt3QkFDL0IsRUFBRSxDQUFDLHlCQUF5QixDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLFFBQVEsQ0FBQztxQkFDOUQsRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUN2QixDQUFDO29CQUNGLEtBQUssQ0FBQyxXQUFXLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztvQkFFeEMsMkNBQTJDO29CQUMzQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUM7b0JBQy9FLE9BQU8sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLEtBQUssQ0FBQyxDQUFDO29CQUU1QyxPQUFPLE9BQU8sQ0FBQztpQkFDaEI7Z0JBRUQsK0JBQStCO2dCQUMvQixPQUFPLEVBQUUsQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztZQUNuRCxDQUFDLENBQUM7WUFFRixPQUFPLEVBQUUsQ0FBQyxTQUFTLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ25DLENBQUMsQ0FBQztRQUVGLE9BQU8sV0FBVyxDQUFDO0lBQ3JCLENBQUMsQ0FBQztBQUNKLENBQUM7QUFwR0Qsd0RBb0dDO0FBRUQsU0FBUyxxQkFBcUIsQ0FBQyxJQUFhO0lBQzFDLE1BQU0sT0FBTyxHQUFnQixFQUFFLENBQUM7SUFDaEMsMkRBQTJEO0lBQzNELEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLENBQUMsS0FBSyxFQUFFLEVBQUU7UUFDOUIsa0RBQWtEO1FBQ2xELDRGQUE0RjtRQUM1Riw2Q0FBNkM7UUFDN0MsSUFBSSxFQUFFLENBQUMsa0JBQWtCLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLElBQUksRUFBRTtZQUM5QyxPQUFPLENBQUMsSUFBSSxDQUFDO2dCQUNYLElBQUksRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUk7Z0JBQ3JCLFdBQVcsRUFBRSxLQUFLO2dCQUNsQixVQUFVLEVBQUUsRUFBRTthQUNmLENBQUMsQ0FBQztZQUVILE9BQU87U0FDUjtRQUVELElBQUksS0FBSyxDQUFDLElBQUksS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLGlCQUFpQixFQUFFO1lBQ2xELE9BQU87U0FDUjtRQUNELE1BQU0sT0FBTyxHQUFHLEtBQTZCLENBQUM7UUFDOUMsSUFBSSxPQUFPLENBQUMsZUFBZSxDQUFDLFlBQVksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ25ELE9BQU87U0FDUjtRQUNELE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3hELElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQyxVQUFVLEVBQUU7WUFDbEQsT0FBTztTQUNSO1FBQ0QsTUFBTSxJQUFJLEdBQUksT0FBTyxDQUFDLElBQXNCLENBQUMsSUFBSSxDQUFDO1FBQ2xELE1BQU0sSUFBSSxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUM7UUFDakMsSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLEVBQUUsQ0FBQyxVQUFVLENBQUMsdUJBQXVCLEVBQUU7WUFDaEUsT0FBTztTQUNSO1FBQ0QsSUFBSyxJQUFtQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQyxjQUFjLEVBQUU7WUFDekYsT0FBTztTQUNSO1FBQ0QsTUFBTSxRQUFRLEdBQUksSUFBbUMsQ0FBQyxVQUErQixDQUFDO1FBQ3RGLElBQUksUUFBUSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsRUFBRTtZQUNqRSxPQUFPO1NBQ1I7UUFDRCxNQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsVUFBbUMsQ0FBQztRQUN4RCxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDakMsT0FBTztTQUNSO1FBQ0QsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQyxtQkFBbUIsRUFBRTtZQUNwRSxPQUFPO1NBQ1I7UUFDRCxNQUFNLE9BQU8sR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQTJCLENBQUM7UUFDaEUsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLEVBQUUsQ0FBQyxVQUFVLENBQUMsZUFBZSxFQUFFO1lBQzVGLE9BQU87U0FDUjtRQUNELElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLEVBQUUsQ0FBQyxVQUFVLENBQUMsVUFBVSxFQUFFO1lBQ25FLE9BQU87U0FDUjtRQUNELElBQUssT0FBTyxDQUFDLElBQXNCLENBQUMsSUFBSSxLQUFLLElBQUksRUFBRTtZQUNqRCxPQUFPO1NBQ1I7UUFDRCxPQUFPLENBQUMsSUFBSSxDQUFDO1lBQ1gsSUFBSTtZQUNKLFdBQVcsRUFBRSxPQUFPO1lBQ3BCLFFBQVEsRUFBRSxFQUFFO1lBQ1osVUFBVSxFQUFFLEVBQUU7U0FDZixDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztJQUVILE9BQU8sT0FBTyxDQUFDO0FBQ2pCLENBQUM7QUFFRCxTQUFTLHdDQUF3QyxDQUMvQyxJQUFhLEVBQ2IsT0FBdUIsRUFDdkIsT0FBb0I7SUFFcEIsbURBQW1EO0lBQ25ELEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLENBQUMsS0FBSyxFQUFFLEVBQUU7UUFDOUIsSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLEVBQUUsQ0FBQyxVQUFVLENBQUMsbUJBQW1CLEVBQUU7WUFDcEQsT0FBTztTQUNSO1FBQ0QsTUFBTSxtQkFBbUIsR0FBRyxLQUErQixDQUFDO1FBQzVELElBQUksbUJBQW1CLENBQUMsVUFBVSxDQUFDLElBQUksS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLGdCQUFnQixFQUFFO1lBQzFFLE9BQU87U0FDUjtRQUNELE1BQU0sS0FBSyxHQUFHLG1CQUFtQixDQUFDLFVBQWlDLENBQUM7UUFDcEUsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLHdCQUF3QixFQUFFO1lBQzlELE9BQU87U0FDUjtRQUNELE1BQU0sVUFBVSxHQUFHLEtBQUssQ0FBQyxJQUFtQyxDQUFDO1FBQzdELElBQUksVUFBVSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQyxVQUFVLEVBQUU7WUFDM0QsT0FBTztTQUNSO1FBRUQsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLG1CQUFtQixDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNsRSxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ1gsT0FBTztTQUNSO1FBRUQsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQztRQUNsQyxJQUFJLEtBQUssSUFBSSxTQUFTLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDNUMsT0FBTztTQUNSO1FBRUQsTUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzdFLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDZCxPQUFPO1NBQ1I7UUFDRCxNQUFNLFNBQVMsR0FBa0IsRUFBRSxtQkFBbUIsRUFBRSxTQUFTLEVBQUUsQ0FBQztRQUVwRSxTQUFTLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUN2QyxDQUFDLENBQUMsQ0FBQztJQUVILDZEQUE2RDtJQUM3RCxPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLE1BQU0sSUFBSSxDQUFDLENBQUMsQ0FBQztBQUN6RCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmludGVyZmFjZSBDbGFzc0RhdGEge1xuICBuYW1lOiBzdHJpbmc7XG4gIGRlY2xhcmF0aW9uOiB0cy5WYXJpYWJsZURlY2xhcmF0aW9uIHwgdHMuQ2xhc3NEZWNsYXJhdGlvbjtcbiAgZnVuY3Rpb24/OiB0cy5GdW5jdGlvbkV4cHJlc3Npb247XG4gIHN0YXRlbWVudHM6IFN0YXRlbWVudERhdGFbXTtcbn1cblxuaW50ZXJmYWNlIFN0YXRlbWVudERhdGEge1xuICBleHByZXNzaW9uU3RhdGVtZW50OiB0cy5FeHByZXNzaW9uU3RhdGVtZW50O1xuICBob3N0Q2xhc3M6IENsYXNzRGF0YTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZvbGRGaWxlVHJhbnNmb3JtZXIocHJvZ3JhbTogdHMuUHJvZ3JhbSk6IHRzLlRyYW5zZm9ybWVyRmFjdG9yeTx0cy5Tb3VyY2VGaWxlPiB7XG4gIGNvbnN0IGNoZWNrZXIgPSBwcm9ncmFtLmdldFR5cGVDaGVja2VyKCk7XG5cbiAgcmV0dXJuIChjb250ZXh0OiB0cy5UcmFuc2Zvcm1hdGlvbkNvbnRleHQpOiB0cy5UcmFuc2Zvcm1lcjx0cy5Tb3VyY2VGaWxlPiA9PiB7XG5cbiAgICBjb25zdCB0cmFuc2Zvcm1lcjogdHMuVHJhbnNmb3JtZXI8dHMuU291cmNlRmlsZT4gPSAoc2Y6IHRzLlNvdXJjZUZpbGUpID0+IHtcblxuICAgICAgY29uc3Qgc3RhdGVtZW50c1RvUmVtb3ZlOiB0cy5FeHByZXNzaW9uU3RhdGVtZW50W10gPSBbXTtcbiAgICAgIGNvbnN0IGNsYXNzZXNXaXRob3V0U3RhdGVtZW50cyA9IGZpbmRDbGFzc0RlY2xhcmF0aW9ucyhzZik7XG4gICAgICBsZXQgY2xhc3NlcyA9IGZpbmRDbGFzc2VzV2l0aFN0YXRpY1Byb3BlcnR5QXNzaWdubWVudHMoc2YsIGNoZWNrZXIsIGNsYXNzZXNXaXRob3V0U3RhdGVtZW50cyk7XG5cbiAgICAgIGNvbnN0IHZpc2l0b3I6IHRzLlZpc2l0b3IgPSAobm9kZTogdHMuTm9kZSk6IHRzLlZpc2l0UmVzdWx0PHRzLk5vZGU+ID0+IHtcbiAgICAgICAgaWYgKGNsYXNzZXMubGVuZ3RoID09PSAwICYmIHN0YXRlbWVudHNUb1JlbW92ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAvLyBUaGVyZSBhcmUgbm8gbW9yZSBzdGF0ZW1lbnRzIHRvIGZvbGQuXG4gICAgICAgICAgcmV0dXJuIHRzLnZpc2l0RWFjaENoaWxkKG5vZGUsIHZpc2l0b3IsIGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgbm9kZSBpcyBhIHN0YXRlbWVudCB0byBiZSBkcm9wcGVkLlxuICAgICAgICBjb25zdCBzdG10SWR4ID0gc3RhdGVtZW50c1RvUmVtb3ZlLmluZGV4T2Yobm9kZSBhcyB0cy5FeHByZXNzaW9uU3RhdGVtZW50KTtcbiAgICAgICAgaWYgKHN0bXRJZHggIT0gLTEpIHtcbiAgICAgICAgICBzdGF0ZW1lbnRzVG9SZW1vdmUuc3BsaWNlKHN0bXRJZHgsIDEpO1xuXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIG5vZGUgaXMgYSBFUzUgY2xhc3MgdG8gYWRkIHN0YXRlbWVudHMgdG8uXG4gICAgICAgIGxldCBjbGF6eiA9IGNsYXNzZXMuZmluZCgoY2wpID0+IGNsLmZ1bmN0aW9uID09PSBub2RlKTtcbiAgICAgICAgaWYgKGNsYXp6KSB7XG4gICAgICAgICAgY29uc3QgZnVuY3Rpb25FeHByZXNzaW9uID0gbm9kZSBhcyB0cy5GdW5jdGlvbkV4cHJlc3Npb247XG5cbiAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgYm9keSB3aXRoIGFsbCB0aGUgb3JpZ2luYWwgc3RhdGVtZW50cywgcGx1cyBuZXcgb25lcyxcbiAgICAgICAgICAvLyBwbHVzIHJldHVybiBzdGF0ZW1lbnQuXG4gICAgICAgICAgY29uc3QgbmV3Qm9keSA9IHRzLmNyZWF0ZUJsb2NrKFtcbiAgICAgICAgICAgIC4uLmZ1bmN0aW9uRXhwcmVzc2lvbi5ib2R5LnN0YXRlbWVudHMuc2xpY2UoMCwgLTEpLFxuICAgICAgICAgICAgLi4uY2xhenouc3RhdGVtZW50cy5tYXAoc3QgPT4gc3QuZXhwcmVzc2lvblN0YXRlbWVudCksXG4gICAgICAgICAgICAuLi5mdW5jdGlvbkV4cHJlc3Npb24uYm9keS5zdGF0ZW1lbnRzLnNsaWNlKC0xKSxcbiAgICAgICAgICBdKTtcblxuICAgICAgICAgIGNvbnN0IG5ld05vZGUgPSB0cy5jcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24oXG4gICAgICAgICAgICBmdW5jdGlvbkV4cHJlc3Npb24ubW9kaWZpZXJzLFxuICAgICAgICAgICAgZnVuY3Rpb25FeHByZXNzaW9uLmFzdGVyaXNrVG9rZW4sXG4gICAgICAgICAgICBmdW5jdGlvbkV4cHJlc3Npb24ubmFtZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uRXhwcmVzc2lvbi50eXBlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGZ1bmN0aW9uRXhwcmVzc2lvbi5wYXJhbWV0ZXJzLFxuICAgICAgICAgICAgZnVuY3Rpb25FeHByZXNzaW9uLnR5cGUsXG4gICAgICAgICAgICBuZXdCb2R5LFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBVcGRhdGUgcmVtYWluaW5nIGNsYXNzZXMgYW5kIHN0YXRlbWVudHMuXG4gICAgICAgICAgc3RhdGVtZW50c1RvUmVtb3ZlLnB1c2goLi4uY2xhenouc3RhdGVtZW50cy5tYXAoc3QgPT4gc3QuZXhwcmVzc2lvblN0YXRlbWVudCkpO1xuICAgICAgICAgIGNsYXNzZXMgPSBjbGFzc2VzLmZpbHRlcihjbCA9PiBjbCAhPSBjbGF6eik7XG5cbiAgICAgICAgICAvLyBSZXBsYWNlIG5vZGUgd2l0aCBtb2RpZmllZCBvbmUuXG4gICAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiBub2RlIGlzIGEgRVMyMDE1IGNsYXNzIHRvIHJlcGxhY2Ugd2l0aCBhIHB1cmUgSUlGRS5cbiAgICAgICAgY2xhenogPSBjbGFzc2VzLmZpbmQoKGNsKSA9PiAhY2wuZnVuY3Rpb24gJiYgY2wuZGVjbGFyYXRpb24gPT09IG5vZGUpO1xuICAgICAgICBpZiAoY2xhenopIHtcbiAgICAgICAgICBjb25zdCBjbGFzc1N0YXRlbWVudCA9IGNsYXp6LmRlY2xhcmF0aW9uIGFzIHRzLkNsYXNzRGVjbGFyYXRpb247XG4gICAgICAgICAgY29uc3QgaW5uZXJSZXR1cm4gPSB0cy5jcmVhdGVSZXR1cm4odHMuY3JlYXRlSWRlbnRpZmllcihjbGF6ei5uYW1lKSk7XG5cbiAgICAgICAgICBjb25zdCBpaWZlID0gdHMuY3JlYXRlSW1tZWRpYXRlbHlJbnZva2VkRnVuY3Rpb25FeHByZXNzaW9uKFtcbiAgICAgICAgICAgIGNsYXNzU3RhdGVtZW50LFxuICAgICAgICAgICAgLi4uY2xhenouc3RhdGVtZW50cy5tYXAoc3QgPT4gc3QuZXhwcmVzc2lvblN0YXRlbWVudCksXG4gICAgICAgICAgICBpbm5lclJldHVybixcbiAgICAgICAgICBdKTtcblxuICAgICAgICAgIGNvbnN0IHB1cmVJaWZlID0gdHMuYWRkU3ludGhldGljTGVhZGluZ0NvbW1lbnQoXG4gICAgICAgICAgICBpaWZlLFxuICAgICAgICAgICAgdHMuU3ludGF4S2luZC5NdWx0aUxpbmVDb21tZW50VHJpdmlhLFxuICAgICAgICAgICAgJ0BfX1BVUkVfXycsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gTW92ZSB0aGUgb3JpZ2luYWwgY2xhc3MgbW9kaWZpZXJzIHRvIHRoZSB2YXIgc3RhdGVtZW50LlxuICAgICAgICAgIGNvbnN0IG5ld05vZGUgPSB0cy5jcmVhdGVWYXJpYWJsZVN0YXRlbWVudChcbiAgICAgICAgICAgIGNsYXp6LmRlY2xhcmF0aW9uLm1vZGlmaWVycyxcbiAgICAgICAgICAgIHRzLmNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KFtcbiAgICAgICAgICAgICAgdHMuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbihjbGF6ei5uYW1lLCB1bmRlZmluZWQsIHB1cmVJaWZlKSxcbiAgICAgICAgICAgIF0sIHRzLk5vZGVGbGFncy5Db25zdCksXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjbGF6ei5kZWNsYXJhdGlvbi5tb2RpZmllcnMgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAvLyBVcGRhdGUgcmVtYWluaW5nIGNsYXNzZXMgYW5kIHN0YXRlbWVudHMuXG4gICAgICAgICAgc3RhdGVtZW50c1RvUmVtb3ZlLnB1c2goLi4uY2xhenouc3RhdGVtZW50cy5tYXAoc3QgPT4gc3QuZXhwcmVzc2lvblN0YXRlbWVudCkpO1xuICAgICAgICAgIGNsYXNzZXMgPSBjbGFzc2VzLmZpbHRlcihjbCA9PiBjbCAhPSBjbGF6eik7XG5cbiAgICAgICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSByZXR1cm4gbm9kZSBhcyBpcy5cbiAgICAgICAgcmV0dXJuIHRzLnZpc2l0RWFjaENoaWxkKG5vZGUsIHZpc2l0b3IsIGNvbnRleHQpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHRzLnZpc2l0Tm9kZShzZiwgdmlzaXRvcik7XG4gICAgfTtcblxuICAgIHJldHVybiB0cmFuc2Zvcm1lcjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmluZENsYXNzRGVjbGFyYXRpb25zKG5vZGU6IHRzLk5vZGUpOiBDbGFzc0RhdGFbXSB7XG4gIGNvbnN0IGNsYXNzZXM6IENsYXNzRGF0YVtdID0gW107XG4gIC8vIEZpbmQgYWxsIGNsYXNzIGRlY2xhcmF0aW9ucywgYnVpbGQgYSBDbGFzc0RhdGEgZm9yIGVhY2guXG4gIHRzLmZvckVhY2hDaGlsZChub2RlLCAoY2hpbGQpID0+IHtcbiAgICAvLyBDaGVjayBpZiBpdCBpcyBhIG5hbWVkIGNsYXNzIGRlY2xhcmF0aW9uIGZpcnN0LlxuICAgIC8vIFRlY2huaWNhbGx5IGl0IGRvZXNuJ3QgbmVlZCBhIG5hbWUgaW4gVFMgaWYgaXQncyB0aGUgZGVmYXVsdCBleHBvcnQsIGJ1dCB3aGVuIGRvd25sZXZlbGVkXG4gICAgLy8gaXQgd2lsbCBiZSBoYXZlIGEgbmFtZSAoZS5nLiBgZGVmYXVsdF8xYCkuXG4gICAgaWYgKHRzLmlzQ2xhc3NEZWNsYXJhdGlvbihjaGlsZCkgJiYgY2hpbGQubmFtZSkge1xuICAgICAgY2xhc3Nlcy5wdXNoKHtcbiAgICAgICAgbmFtZTogY2hpbGQubmFtZS50ZXh0LFxuICAgICAgICBkZWNsYXJhdGlvbjogY2hpbGQsXG4gICAgICAgIHN0YXRlbWVudHM6IFtdLFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGQua2luZCAhPT0gdHMuU3ludGF4S2luZC5WYXJpYWJsZVN0YXRlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2YXJTdG10ID0gY2hpbGQgYXMgdHMuVmFyaWFibGVTdGF0ZW1lbnQ7XG4gICAgaWYgKHZhclN0bXQuZGVjbGFyYXRpb25MaXN0LmRlY2xhcmF0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHZhckRlY2wgPSB2YXJTdG10LmRlY2xhcmF0aW9uTGlzdC5kZWNsYXJhdGlvbnNbMF07XG4gICAgaWYgKHZhckRlY2wubmFtZS5raW5kICE9PSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9ICh2YXJEZWNsLm5hbWUgYXMgdHMuSWRlbnRpZmllcikudGV4dDtcbiAgICBjb25zdCBleHByID0gdmFyRGVjbC5pbml0aWFsaXplcjtcbiAgICBpZiAoIWV4cHIgfHwgZXhwci5raW5kICE9PSB0cy5TeW50YXhLaW5kLlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgoZXhwciBhcyB0cy5QYXJlbnRoZXNpemVkRXhwcmVzc2lvbikuZXhwcmVzc2lvbi5raW5kICE9PSB0cy5TeW50YXhLaW5kLkNhbGxFeHByZXNzaW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNhbGxFeHByID0gKGV4cHIgYXMgdHMuUGFyZW50aGVzaXplZEV4cHJlc3Npb24pLmV4cHJlc3Npb24gYXMgdHMuQ2FsbEV4cHJlc3Npb247XG4gICAgaWYgKGNhbGxFeHByLmV4cHJlc3Npb24ua2luZCAhPT0gdHMuU3ludGF4S2luZC5GdW5jdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZm4gPSBjYWxsRXhwci5leHByZXNzaW9uIGFzIHRzLkZ1bmN0aW9uRXhwcmVzc2lvbjtcbiAgICBpZiAoZm4uYm9keS5zdGF0ZW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGZuLmJvZHkuc3RhdGVtZW50c1swXS5raW5kICE9PSB0cy5TeW50YXhLaW5kLkZ1bmN0aW9uRGVjbGFyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5uZXJGbiA9IGZuLmJvZHkuc3RhdGVtZW50c1swXSBhcyB0cy5GdW5jdGlvbkRlY2xhcmF0aW9uO1xuICAgIGlmIChmbi5ib2R5LnN0YXRlbWVudHNbZm4uYm9keS5zdGF0ZW1lbnRzLmxlbmd0aCAtIDFdLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuUmV0dXJuU3RhdGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaW5uZXJGbi5uYW1lIHx8IGlubmVyRm4ubmFtZS5raW5kICE9PSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKChpbm5lckZuLm5hbWUgYXMgdHMuSWRlbnRpZmllcikudGV4dCAhPT0gbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGFzc2VzLnB1c2goe1xuICAgICAgbmFtZSxcbiAgICAgIGRlY2xhcmF0aW9uOiB2YXJEZWNsLFxuICAgICAgZnVuY3Rpb246IGZuLFxuICAgICAgc3RhdGVtZW50czogW10sXG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBjbGFzc2VzO1xufVxuXG5mdW5jdGlvbiBmaW5kQ2xhc3Nlc1dpdGhTdGF0aWNQcm9wZXJ0eUFzc2lnbm1lbnRzKFxuICBub2RlOiB0cy5Ob2RlLFxuICBjaGVja2VyOiB0cy5UeXBlQ2hlY2tlcixcbiAgY2xhc3NlczogQ2xhc3NEYXRhW10sXG4pIHtcbiAgLy8gRmluZCBlYWNoIGFzc2lnbm1lbnQgb3V0c2lkZSBvZiB0aGUgZGVjbGFyYXRpb24uXG4gIHRzLmZvckVhY2hDaGlsZChub2RlLCAoY2hpbGQpID0+IHtcbiAgICBpZiAoY2hpbGQua2luZCAhPT0gdHMuU3ludGF4S2luZC5FeHByZXNzaW9uU3RhdGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGV4cHJlc3Npb25TdGF0ZW1lbnQgPSBjaGlsZCBhcyB0cy5FeHByZXNzaW9uU3RhdGVtZW50O1xuICAgIGlmIChleHByZXNzaW9uU3RhdGVtZW50LmV4cHJlc3Npb24ua2luZCAhPT0gdHMuU3ludGF4S2luZC5CaW5hcnlFeHByZXNzaW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJpbkV4ID0gZXhwcmVzc2lvblN0YXRlbWVudC5leHByZXNzaW9uIGFzIHRzLkJpbmFyeUV4cHJlc3Npb247XG4gICAgaWYgKGJpbkV4LmxlZnQua2luZCAhPT0gdHMuU3ludGF4S2luZC5Qcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcHJvcEFjY2VzcyA9IGJpbkV4LmxlZnQgYXMgdHMuUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uO1xuICAgIGlmIChwcm9wQWNjZXNzLmV4cHJlc3Npb24ua2luZCAhPT0gdHMuU3ludGF4S2luZC5JZGVudGlmaWVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc3ltYm9sID0gY2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKHByb3BBY2Nlc3MuZXhwcmVzc2lvbik7XG4gICAgaWYgKCFzeW1ib2wpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkZWNscyA9IHN5bWJvbC5kZWNsYXJhdGlvbnM7XG4gICAgaWYgKGRlY2xzID09IHVuZGVmaW5lZCB8fCBkZWNscy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBob3N0Q2xhc3MgPSBjbGFzc2VzLmZpbmQoKGNsYXp6ID0+IGRlY2xzLmluY2x1ZGVzKGNsYXp6LmRlY2xhcmF0aW9uKSkpO1xuICAgIGlmICghaG9zdENsYXNzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlbWVudDogU3RhdGVtZW50RGF0YSA9IHsgZXhwcmVzc2lvblN0YXRlbWVudCwgaG9zdENsYXNzIH07XG5cbiAgICBob3N0Q2xhc3Muc3RhdGVtZW50cy5wdXNoKHN0YXRlbWVudCk7XG4gIH0pO1xuXG4gIC8vIE9ubHkgcmV0dXJuIGNsYXNzZXMgdGhhdCBoYXZlIHN0YXRpYyBwcm9wZXJ0eSBhc3NpZ25tZW50cy5cbiAgcmV0dXJuIGNsYXNzZXMuZmlsdGVyKGNsID0+IGNsLnN0YXRlbWVudHMubGVuZ3RoICE9IDApO1xufVxuIl19